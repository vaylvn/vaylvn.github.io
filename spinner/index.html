<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Vayl Spinner</title>
<style>
  body{font-family:sans-serif;margin:20px;text-align:center;background:#fafafa;color:#222}
  table{margin:10px auto;border-collapse:collapse}
  td,th{border:1px solid #ccc;padding:4px 6px}
  input[type=color]{width:40px;height:30px;border:none;background:none}
  #spinnerCanvas{display:block;margin:20px auto;border-radius:50%;background:white;cursor:pointer}
  #editor input,button{margin:4px}
  #shareUrl{width:80%;padding:4px}
</style>
</head>
<body>
<div id="editor">
  <h2>Spinner Configurator</h2>
  <label>Auto-spin delay (seconds):
    <input type="number" id="spinDelay" min="0" value="0">
  </label>
  <label>
    Auto-spin enabled:
    <input type="checkbox" id="autoSpin">
  </label>
  <br>
  <label>Arrow angle (°):
    <input type="range" id="arrowAngle" min="0" max="360" value="0" style="width:200px;">
    <span id="arrowAngleValue">0</span>°
  </label>

  <table>
    <thead><tr><th>Label</th><th>Color</th><th>Weight</th><th></th></tr></thead>
    <tbody id="segments"></tbody>
  </table>
  <button id="addSegment">+ Add Segment</button>

  <h3>Shareable URL</h3>
  <input id="shareUrl" readonly>
  <button id="copyUrl">Copy</button>

  <h3>Load Existing</h3>
  <input id="urlImport" placeholder="Paste spinner URL">
  <button id="importUrl">Load</button>
</div>

<canvas id="spinnerCanvas" width="400" height="400"></canvas>

<script>
const params = new URLSearchParams(location.search);
const dataParam = params.get("data");
const editor = document.getElementById("editor");
const canvas = document.getElementById("spinnerCanvas");
const ctx = canvas.getContext("2d");

let config = {spinDelay:0,autoSpin:false,arrowAngle:0,segments:[]};
let spinning=false;
let currentRotation=0;
const POINTER_COLOR="#222";

/* ---------- Spinner Rendering ---------- */
function drawSpinner(cfg,rotation=0){
  currentRotation = rotation;
  const total = cfg.segments.reduce((a,b)=>a+b.weight,0)||1;

  // Adjust pointer position based on arrow angle
  const pointerPos = ((2*Math.PI - rotation) + (cfg.arrowAngle*Math.PI/180)) % (2*Math.PI);
  let highlightedIndex=-1;

  // find which segment pointer is over
  let testStart=0;
  cfg.segments.forEach((seg,i)=>{
    const ang=(seg.weight/total)*2*Math.PI;
    const end=testStart+ang;
    if(pointerPos>=testStart && pointerPos<end) highlightedIndex=i;
    testStart=end;
  });

  ctx.clearRect(0,0,400,400);

  // ----- Pass 1: fills -----
  let drawStart = rotation;
  cfg.segments.forEach((seg)=>{
    const ang=(seg.weight/total)*2*Math.PI;
    ctx.beginPath();
    ctx.moveTo(200,200);
    ctx.arc(200,200,200,drawStart,drawStart+ang);
    ctx.closePath();
    ctx.fillStyle = seg.color || "#888";
    ctx.fill();
    drawStart += ang;
  });

  // ----- Pass 2: outlines -----
  drawStart = rotation;
  cfg.segments.forEach((seg,i)=>{
    const ang=(seg.weight/total)*2*Math.PI;
    ctx.beginPath();
    ctx.moveTo(200,200);
    ctx.arc(200,200,200,drawStart,drawStart+ang);
    ctx.closePath();
    ctx.lineWidth = (i===highlightedIndex)?4:2;
    ctx.strokeStyle = (i===highlightedIndex)? "#000":"#fff";
    ctx.stroke();
    drawStart += ang;
  });

  // ----- Labels -----
  drawStart = rotation;
  cfg.segments.forEach((seg)=>{
    const ang=(seg.weight/total)*2*Math.PI;
    const mid = drawStart + ang/2;
    ctx.save();
    ctx.translate(200,200);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="#000";
    ctx.font="16px sans-serif";
    ctx.fillText(seg.label,180,5);
    ctx.restore();
    drawStart += ang;
  });

  // ----- Pointer (rotatable) -----
  ctx.save();
  ctx.translate(200,200);
  ctx.rotate(cfg.arrowAngle*Math.PI/180);
  ctx.beginPath();
  ctx.moveTo(-10,-200);
  ctx.lineTo(10,-200);
  ctx.lineTo(0,-220);
  ctx.closePath();
  ctx.fillStyle=POINTER_COLOR;
  ctx.fill();
  ctx.restore();
}

/* ---------- Spin Logic ---------- */
function startSpin(){
  if(spinning||!config.segments.length)return;
  spinning=true;
  const duration=4000;
  const startTime=performance.now();
  const startRot=currentRotation;
  const targetRot=startRot + 10*Math.PI + Math.random()*Math.PI; // random stop
  requestAnimationFrame(function anim(now){
    const p=Math.min((now-startTime)/duration,1);
    const eased=1-Math.pow(1-p,3);
    const rot=startRot + eased*(targetRot-startRot);
    drawSpinner(config,rot);
    if(p<1)requestAnimationFrame(anim);else spinning=false;
  });
}

/* ---------- Editor Mode ---------- */
if(!dataParam){
  const tableBody=document.getElementById("segments");
  const angleInput=document.getElementById("arrowAngle");
  const angleValue=document.getElementById("arrowAngleValue");

  function addRow(seg={label:"",color:"#"+Math.floor(Math.random()*16777215).toString(16).padStart(6,"0"),weight:1}){
    const row=document.createElement("tr");
    row.innerHTML=`
      <td><input class="label" value="${seg.label}"></td>
      <td><input type="color" class="color" value="${seg.color}"></td>
      <td><input type="number" class="weight" min="1" value="${seg.weight}"></td>
      <td><button class="remove">✕</button></td>`;
    tableBody.appendChild(row);
    row.querySelector(".remove").onclick=()=>{row.remove();updateConfig();};
    ["label","color","weight"].forEach(cls=>{
      row.querySelector("."+cls).oninput=updateConfig;
    });
  }

  document.getElementById("addSegment").onclick=()=>{addRow();updateConfig();};
  document.getElementById("spinDelay").oninput=updateConfig;
  document.getElementById("autoSpin").onchange=updateConfig;
  angleInput.oninput=()=>{
    angleValue.textContent=angleInput.value;
    updateConfig();
  };
  document.getElementById("copyUrl").onclick=()=>{
    navigator.clipboard.writeText(document.getElementById("shareUrl").value);
  };
  document.getElementById("importUrl").onclick=()=>{
    const url=document.getElementById("urlImport").value.trim();
    try{
      const u=new URL(url);
      const enc=u.searchParams.get("data");
      if(!enc)throw 0;
      const cfg=JSON.parse(atob(enc));
      tableBody.innerHTML="";
      document.getElementById("spinDelay").value=cfg.spinDelay??0;
      document.getElementById("autoSpin").checked=!!cfg.autoSpin;
      angleInput.value = cfg.arrowAngle ?? 0;
      angleValue.textContent = angleInput.value;
      cfg.segments.forEach(addRow);
      updateConfig();
    }catch(e){alert("Invalid URL");}
  };

  function updateConfig(){
    const rows=[...tableBody.querySelectorAll("tr")];
    config.segments=rows.map(r=>({
      label:r.querySelector(".label").value,
      color:r.querySelector(".color").value,
      weight:parseFloat(r.querySelector(".weight").value)||1
    }));
    config.spinDelay=parseFloat(document.getElementById("spinDelay").value)||0;
    config.autoSpin=document.getElementById("autoSpin").checked;
    config.arrowAngle=parseFloat(angleInput.value)||0;
    drawSpinner(config);
    const encoded=btoa(JSON.stringify(config));
    const url=`${location.origin}${location.pathname}?data=${encoded}`;
    document.getElementById("shareUrl").value=url;
  }

  addRow();
  updateConfig();

/* ---------- Viewer Mode ---------- */
}else{
  editor.style.display="none";
  try{
    config=JSON.parse(atob(dataParam));
    drawSpinner(config);

    // Allow manual click-to-spin
    canvas.onclick=startSpin;

    if(config.autoSpin){
      const delay=(config.spinDelay??0)*1000;
      setTimeout(startSpin,delay);
    }
  }catch(e){
    document.body.innerHTML="<h3>Invalid or corrupted spinner data.</h3>";
  }
}
</script>
</body>
</html>
