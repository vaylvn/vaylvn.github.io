<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Visual PDF Redactor – Manual Prototype</title>
<style>
  body{background:#0f1720;color:#e6eef8;font-family:system-ui;margin:1rem}
  #viewer{display:flex;flex-direction:column;gap:1rem}
  canvas.page{border:1px solid #222;display:block;margin:auto}
  #controls{margin-bottom:1rem;display:flex;gap:.5rem;flex-wrap:wrap}
  button,input[type=file]{background:#1f3342;border:1px solid #274;
     color:#e6eef8;padding:.4rem .7rem;border-radius:6px;cursor:pointer}
  footer{margin-top:1rem;font-size:.85rem;color:#9fb1c8}
</style>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>
<div id="controls">
  <input id="fileInput" type="file" accept="application/pdf">
  <button id="exportBtn">Export Redacted PDF</button>
  <button id="clearBtn">Clear Boxes</button>
</div>

<div id="viewer"></div>
<footer>
  Click-drag on a page to draw black boxes.  
  Export creates a new PDF with those boxes baked in.  
  (Phase 1 – no auto-detect yet)
</footer>

<script>
/* ----- global state ----- */
let pdfDoc=null;
let scale=1.25;
const redactions={}; // pageNumber -> [{x,y,w,h}]
const viewer=document.getElementById('viewer');

/* load & render pdf pages */
async function renderPDF(arrayBuffer){
  viewer.innerHTML='';
  redactions.clear;
  pdfDoc = await pdfjsLib.getDocument({data:arrayBuffer}).promise;
  for(let i=1;i<=pdfDoc.numPages;i++){
    const page=await pdfDoc.getPage(i);
    const viewport=page.getViewport({scale});
    const canvas=document.createElement('canvas');
    canvas.width=viewport.width;
    canvas.height=viewport.height;
    canvas.className='page';
    viewer.appendChild(canvas);
    const ctx=canvas.getContext('2d');
    await page.render({canvasContext:ctx,viewport}).promise;
    attachOverlay(canvas,i);
  }
}

/* draw/drag overlay logic */
function attachOverlay(canvas,pageNum){
  // keep this inside attachOverlay(canvas, pageNum)
  const ctx = canvas.getContext('2d');
  let start = null;
  let preview = null;

  canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    start = { x: e.clientX - r.left, y: e.clientY - r.top };
    preview = null;
  });

  canvas.addEventListener('mousemove', e => {
    if (!start) return;
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;

    // restore snapshot without clearing whole canvas
    const img = new Image();
    img.src = canvas.dataset.bg;
    img.onload = () => {
      ctx.drawImage(img, 0, 0);
      // draw existing boxes
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      for (const b of redactions[pageNum] || []) ctx.fillRect(b.x, b.y, b.w, b.h);
      // draw current preview box
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(start.x, start.y, x - start.x, y - start.y);
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(start.x, start.y, x - start.x, y - start.y);
    };
  });

  canvas.addEventListener('mouseup', e => {
    if (!start) return;
    const r = canvas.getBoundingClientRect();
    const end = { x: e.clientX - r.left, y: e.clientY - r.top };
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(end.x - start.x);
    const h = Math.abs(end.y - start.y);
    redactions[pageNum].push({ x, y, w, h });

    // repaint final state once
    const img = new Image();
    img.src = canvas.dataset.bg;
    img.onload = () => {
      ctx.drawImage(img, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      for (const b of redactions[pageNum] || []) ctx.fillRect(b.x, b.y, b.w, b.h);
    };
    start = null;
  });

}

/* redraw page with all boxes */
function redraw(canvas,pageNum){
  const ctx=canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // re-render original image layer from stored snapshot (use off-screen copy)
  // simplest: keep background image
  const bg=canvas.dataset.bg;
  if(bg){
    const img=new Image();
    img.onload=()=>{ctx.drawImage(img,0,0); drawBoxes();};
    img.src=bg;
  } else drawBoxes();

  function drawBoxes(){
    ctx.fillStyle='rgba(0,0,0,0.4)';
    for(const b of redactions[pageNum]||[]) ctx.fillRect(b.x,b.y,b.w,b.h);
  }
}

/* snapshot page background after render */
function snapshotBackgrounds(){
  document.querySelectorAll('canvas.page').forEach(c=>{
    c.dataset.bg=c.toDataURL('image/png');
  });
}

/* export new pdf */
async function exportRedacted(){
  if(!pdfDoc)return alert('No PDF loaded');
  const arrayBuffer = await pdfDoc.getData();
  const pdfBytes = new Uint8Array(arrayBuffer);
  const srcDoc = await PDFLib.PDFDocument.load(pdfBytes);
  const dstDoc = await PDFLib.PDFDocument.create();
  for(let i=1;i<=srcDoc.getPageCount();i++){
    const [page] = await dstDoc.copyPages(srcDoc,[i-1]);
    const pageRedactions = redactions[i] || [];
    if(pageRedactions.length){
      const {width,height} = page.getSize();
      const canvas = document.querySelectorAll('canvas.page')[i-1];
      const ratioX = width / canvas.width;
      const ratioY = height / canvas.height;
      pageRedactions.forEach(b=>{
        page.drawRectangle({
          x:b.x*ratioX,
          y:height-(b.y+b.h)*ratioY,
          width:b.w*ratioX,
          height:b.h*ratioY,
          color:PDFLib.rgb(0,0,0),
        });
      });
    }
    dstDoc.addPage(page);
  }
  const outBytes = await dstDoc.save();
  const blob = new Blob([outBytes],{type:'application/pdf'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;a.download='redacted.pdf';a.click();
  URL.revokeObjectURL(url);
}

/* file input */
document.getElementById('fileInput').addEventListener('change',async e=>{
  const f=e.target.files[0];
  if(!f)return;
  const buf=await f.arrayBuffer();
  await renderPDF(buf);
  snapshotBackgrounds();
});
document.getElementById('exportBtn').addEventListener('click',exportRedacted);
document.getElementById('clearBtn').addEventListener('click',()=>{
  Object.keys(redactions).forEach(k=>redactions[k]=[]);
  document.querySelectorAll('canvas.page').forEach(c=>redraw(c,parseInt(c.dataset.page||1)));
});
</script>
</body>
</html>
