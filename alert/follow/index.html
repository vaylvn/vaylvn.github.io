<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vayl Alert Widget (Follow)</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: transparent; overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* ===== Live overlay root ===== */
    #overlay {
      position: fixed; inset: 0;
      display: none; /* enabled in LIVE mode */
      align-items: center; justify-content: center;
      pointer-events: none;
    }
    #stage {
      position: relative;
      width: min(92vw, 1280px);
      height: min(40vh, 360px);
      transform-origin: center center;
    }
    #bg {
      position: absolute; inset: 0;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 5px;
      opacity: 1;
    }
    #textWrap {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 28px;
      box-sizing: border-box;
      text-align: center;
    }
    #alertText {
      white-space: pre-wrap;
      line-height: 1.05;
      font-weight: 800;
      letter-spacing: 0.2px;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,0.55));
      transform-origin: center center;
    }
    .token.user { font-weight: 900; }

    /* ===== Animations ===== */
	
	.inFx {
		margin-top: 5px;
	}
	
	
	


	
	/* FADE OUT */
	.anim-out-fade      { animation: outFade var(--out-ms,320ms) ease-in both;      }
	.anim-out-fadeUp    { animation: outFadeUp var(--out-ms,450ms) ease-in both;    }
	.anim-out-fadeDown  { animation: outFadeDown var(--out-ms,450ms) ease-in both;  }
	.anim-out-fadeLeft  { animation: outFadeLeft var(--out-ms,450ms) ease-in both;  }
	.anim-out-fadeRight { animation: outFadeRight var(--out-ms,450ms) ease-in both; }

	@keyframes outFade {
	  from { opacity: 1; }
	  to   { opacity: 0; }
	}

	@keyframes outFadeUp {
	  from { opacity: 1; transform: translateY(0); }
	  to   { opacity: 0; transform: translateY(-20px); }
	}

	@keyframes outFadeDown {
	  from { opacity: 1; transform: translateY(0); }
	  to   { opacity: 0; transform: translateY(20px); }
	}

	@keyframes outFadeLeft {
	  from { opacity: 1; transform: translateX(0); }
	  to   { opacity: 0; transform: translateX(-20px); }
	}

	@keyframes outFadeRight {
	  from { opacity: 1; transform: translateX(0); }
	  to   { opacity: 0; transform: translateX(20px); }
	}

	/* SLIDE OUT */
	.anim-out-slideUp    { animation: outSlideUp var(--out-ms,320ms) ease-in both; }
	.anim-out-slideDown  { animation: outSlideDown var(--out-ms,320ms) ease-in both; }
	.anim-out-slideLeft  { animation: outSlideLeft var(--out-ms,320ms) ease-in both; }
	.anim-out-slideRight { animation: outSlideRight var(--out-ms,320ms) ease-in both; }

	@keyframes outSlideLeft {
	  from { opacity: 1; transform: translateX(0); }
	  to   { opacity: 0; transform: translateX(100%); }
	}

	@keyframes outSlideRight {
	  from { opacity: 1; transform: translateX(0); }
	  to   { opacity: 0; transform: translateX(-100%); }
	}

	@keyframes outSlideUp {
	  from { opacity: 1; transform: translateY(0); }
	  to   { opacity: 0; transform: translateY(100%); }
	}

	@keyframes outSlideDown {
	  from { opacity: 1; transform: translateY(0); }
	  to   { opacity: 0; transform: translateY(-100%); }
	}


	/* TRANSFORM OUT */
	.anim-out-spin {
	  animation: outSpin var(--out-ms,320ms) ease-in both;
	}

	@keyframes outSpin {
	  from { opacity: 1; transform: rotate(0deg) scale(1); }
	  to   { opacity: 0; transform: rotate(6deg) scale(0.96); }
	}
	
	/* BLUR OUT */
	.anim-out-zoomBlur {
	  animation: outZoomBlur var(--out-ms,320ms) ease-in both;
	}

	@keyframes outZoomBlur {
	  from {
		opacity: 1;
		transform: scale(1);
		filter: blur(0);
	  }
	  to {
		opacity: 0;
		transform: scale(0.92);
		filter: blur(6px);
	  }
	}


	
	
	/* FADE IN */
	.anim-in-fade       { animation: inFade var(--in-ms,450ms) ease-out both;       }
	.anim-in-fadeUp    { animation: inFadeUp var(--in-ms,450ms) ease-out both; }
	.anim-in-fadeDown  { animation: inFadeDown var(--in-ms,450ms) ease-out both; }
	.anim-in-fadeLeft  { animation: inFadeLeft var(--in-ms,450ms) ease-out both; }
	.anim-in-fadeRight { animation: inFadeRight var(--in-ms,450ms) ease-out both; }

	@keyframes inFade {
	  from { opacity: 0; }
	  to   { opacity: 1; }
	}

	@keyframes inFadeUp {
	  from { opacity: 0; transform: translateY(20px); }
	  to   { opacity: 1; transform: translateY(0); }
	}

	@keyframes inFadeDown {
	  from { opacity: 0; transform: translateY(-20px); }
	  to   { opacity: 1; transform: translateY(0); }
	}

	@keyframes inFadeLeft {
	  from { opacity: 0; transform: translateX(20px); }
	  to   { opacity: 1; transform: translateX(0); }
	}

	@keyframes inFadeRight {
	  from { opacity: 0; transform: translateX(-20px); }
	  to   { opacity: 1; transform: translateX(0); }
	}

	/* SLIDE IN */
	.anim-in-slideUp    { animation: inSlideUp var(--in-ms,420ms) ease-out both; }
	.anim-in-slideDown  { animation: inSlideDown var(--in-ms,420ms) ease-out both; }
	.anim-in-slideLeft  { animation: inSlideLeft var(--in-ms,420ms) ease-out both; }
	.anim-in-slideRight { animation: inSlideRight var(--in-ms,420ms) ease-out both; }

	@keyframes inSlideLeft {
	  from { opacity: 0; transform: translateX(100%); }
	  to   { opacity: 1; transform: translateX(0); }
	}

	@keyframes inSlideRight {
	  from { opacity: 0; transform: translateX(-100%); }
	  to   { opacity: 1; transform: translateX(0); }
	}

	@keyframes inSlideUp {
	  from { opacity: 0; transform: translateY(100%); }
	  to   { opacity: 1; transform: translateY(0); }
	}

	@keyframes inSlideDown {
	  from { opacity: 0; transform: translateY(-100%); }
	  to   { opacity: 1; transform: translateY(0); }
	}


	/* TRANSFORM IN */
	.anim-in-pop {
	  animation: inPop var(--in-ms,360ms) cubic-bezier(.2,1.5,.2,1) both;
	}

	@keyframes inPop {
	  0%   { opacity: 0; transform: scale(0.86); }
	  70%  { opacity: 1; transform: scale(1.04); }
	  100% { opacity: 1; transform: scale(1); }
	}

	.anim-in-spin {
	  animation: inSpin var(--in-ms,420ms) ease-out both;
	}

	@keyframes inSpin {
	  from { opacity: 0; transform: rotate(-6deg) scale(0.95); }
	  to   { opacity: 1; transform: rotate(0deg) scale(1); }
	}

	/* BLUR IN */
	.anim-in-zoomBlur {
	  animation: inZoomBlur var(--in-ms,420ms) ease-out both;
	}

	@keyframes inZoomBlur {
	  from {
		opacity: 0;
		transform: scale(1.12);
		filter: blur(8px);
	  }
	  to {
		opacity: 1;
		transform: scale(1);
		filter: blur(0);
	  }
	}




    /* Text FX */
    .fx-none {}
    .fx-wiggle { animation: wiggle 900ms ease-in-out infinite; }
    @keyframes wiggle {
      0%,100% { transform: rotate(0deg) }
      25% { transform: rotate(-0.6deg) }
      75% { transform: rotate(0.6deg) }
    }
    .fx-bounce { animation: bounce 750ms ease-in-out infinite; }
    @keyframes bounce {
      0%,100% { transform: translateY(0) }
      50% { transform: translateY(-4px) }
    }
	.fx-pulse {
	  animation: pulse 900ms ease-in-out infinite;
	}
	@keyframes pulse {
	  0%,100% { transform: scale(1); }
	  50% { transform: scale(1.05); }
	}
	.fx-float {
	  animation: float 2.2s ease-in-out infinite;
	}
	@keyframes float {
	  0%,100% { transform: translateY(0); }
	  50% { transform: translateY(-6px); }
	}
	.fx-jitter {
	  animation: jitter 300ms steps(2,end) infinite;
	}
	@keyframes jitter {
	  0% { transform: translate(0,0); }
	  25% { transform: translate(-1px,1px); }
	  50% { transform: translate(1px,-1px); }
	  75% { transform: translate(-1px,-1px); }
	}



    /* ===== Debug HUD ===== */
    #hud {
      position: fixed; left: 10px; top: 10px;
      display: none;
      padding: 8px 10px;
      border-radius: 5px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: #eaeaea;
      pointer-events: none;
      max-width: 65vw;
      white-space: pre-wrap;
    }

    /* ===== Editor UI ===== */
    #editor {
      display: none; /* enabled in EDITOR mode */
      position: fixed; inset: 0;
      background: #0b0c10;
      color: #e9e9e9;
      overflow: auto;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 16px 34px;
      box-sizing: border-box;
    }
    .row {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
	  margin-top: 10px; 
      align-items: start;
    }
    .card {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 5px;
      padding: 14px;
    }
    h1 { margin: 6px 0 10px; font-size: 16px; font-weight: 800; opacity: 0.95; }
    h2 { margin: 0 0 10px; font-size: 13px; font-weight: 800; opacity: 0.9; }
    label { display: block; margin: 10px 0 6px; font-size: 12px; opacity: 0.92; }
    input, select, textarea, button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 5px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: #fff;
      padding: 10px 10px;
      outline: none;
    }
    textarea { min-height: 68px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .btnRow { display: flex; gap: 10px; margin-top: 12px; }
    button { cursor: pointer; font-weight: 800; }
    button.secondary { background: rgba(255,255,255,0.02); }
    .mini {
      font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      opacity: 0.85;
    }

    /* Editor preview */
    #previewBox {
      margin-top: 10px;
      height: 240px;
      border-radius: 5px;
      border: 1px solid rgba(255,255,255,0.1);
      background: #000;
      position: relative;
      overflow: hidden;
    }
    #previewBox iframe {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      border: 0;
      background: transparent;
    }
  </style>
</head>
<body>

  <!-- LIVE overlay -->
  <div id="overlay">
    <div id="stage">
      <div id="bg"></div>
      <div id="textWrap">
        <div id="alertText"></div>
      </div>
    </div>
  </div>
  <div id="hud"></div>

  <!-- EDITOR -->
  <div id="editor">
    <div class="wrap">
      <h1>Vayl Alert Widget â€” Follow</h1>
      <div class="row">
        <div class="card">
          <h2>Template & Text</h2>

          <label>Template</label>
          <select id="tpl">
            <option value="neo_fade">neo_fade</option>
            <option value="minimal_pop">minimal_pop</option>
          </select>

          <label>Background image URL (optional)</label>
          <input id="bgUrl" placeholder="https://.../bg.png" />

          <label>Text template</label>
          <textarea id="txt">NEW FOLLOWER
{user}</textarea>


          <div class="grid2">
            <div>
              <label>Font family</label>
              <select id="font">
                <option value="system">System</option>
                <option value="Inter">Inter (if available)</option>
                <option value="Arial">Arial</option>
                <option value="Impact">Impact</option>
              </select>
            </div>
            <div>
              <label>Font size</label>
              <input id="fontSize" type="number" min="10" max="140" value="30" />
            </div>
          </div>

          <div class="grid2">
            <div>
              <label>Text color</label>
              <input id="color" type="text" value="#FFFFFF" />
            </div>
            <div>
              <label>{tag} color</label>
              <input id="userColor" type="text" value="#EF767A" />
            </div>
          </div>

          <div class="grid3">
            <div>
              <label>In effect</label>
              <div>
	
				  <select id="inFxCategory">
					<option value="fade">Fade</option>
					<option value="transform">Transform</option>
					<option value="slide">Slide</option>
					<option value="blur">Blur</option>
				  </select>

				  <select id="inFx">
					<!-- populated dynamically -->
				  </select>
				</div>
            </div>

            <div>
              <label>Out effect</label>
			  <div>
				<select id="outFxCategory">
				  <option value="fade">Fade</option>
				  <option value="slide">Slide</option>
				  <option value="transform">Transform</option>
				  <option value="blur">Blur</option>
				</select>

				<select id="outFx">
				  <!-- populated dynamically -->
				</select>
			  </div>
			</div>

        
			
			
            <div>
              <label>Text FX</label>
              <select id="textFx">
                <option value="none">none</option>
                <option value="wiggle">wiggle</option>
                <option value="bounce">bounce</option>
				<option value="pulse">pulse</option>
				<option value="float">float</option>
				<option value="jitter">jitter</option>
              </select>
            </div>
          </div>

          <div class="grid3">
            <div>
              <label>Duration (ms)</label>
              <input id="dur" type="number" min="800" max="30000" value="5500" />
            </div>
            <div>
              <label>In ms</label>
              <input id="inMs" type="number" min="50" max="5000" value="450" />
            </div>
            <div>
              <label>Out ms</label>
              <input id="outMs" type="number" min="50" max="5000" value="450" />
            </div>
          </div>

          <label>Sound (URL or filename)</label>
          <input id="sound" placeholder="follow_pop.wav OR https://.../sound.wav" value="follow_pop.wav" />

          <div class="btnRow">
            <button id="copyUrl">Copy LIVE URL</button>
            <button class="secondary" id="openLive">Open LIVE preview</button>
          </div>
		  
		  <div class="row">
			  <input
				id="loadUrl"
				placeholder="Paste LIVE alert URL here"
				style="flex:1;"
			  />
			  <button id="loadBtn">Load URL</button>
			</div>

		  
        </div>

        <div class="card">
          <h2>Preview</h2>
          <div class="mini">This preview is the same page loaded in LIVE mode with a fake event.</div>
          <div id="previewBox">
            <iframe id="previewFrame" title="Preview"></iframe>
          </div>

          <div class="btnRow">
            <button class="secondary" id="testAnim">Test animation</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ==============================
   Vayl Alert Widget (Single Page)
   - Editor mode: no ?data=...
   - Live mode:   ?data=<base64url(JSON)>
   ============================== */

const IN_EFFECTS = {
	fade: [
	  { value: "fade", label: "Fade" },
	  { value: "fadeUp", label: "Fade Up" },
	  { value: "fadeDown", label: "Fade Down" },
	  { value: "fadeLeft", label: "Fade Left" },
	  { value: "fadeRight", label: "Fade Right" }
	],


  slide: [
    { value: "slideUp", label: "Slide Up" },
    { value: "slideDown", label: "Slide Down" },
    { value: "slideLeft", label: "Slide Left" },
    { value: "slideRight", label: "Slide Right" }
  ],

  transform: [
    { value: "pop", label: "Pop" },
    { value: "spin", label: "Spin" }
  ],

  blur: [
    { value: "zoomBlur", label: "Zoom Blur" }
  ]
};


const OUT_EFFECTS = {
  fade: [
	  { value: "fade", label: "Fade" },
	  { value: "fadeUp", label: "Fade Up" },
	  { value: "fadeDown", label: "Fade Down" },
	  { value: "fadeLeft", label: "Fade Left" },
	  { value: "fadeRight", label: "Fade Right" }
	],


  slide: [
    { value: "slideUp", label: "Slide Up" },
    { value: "slideDown", label: "Slide Down" },
    { value: "slideLeft", label: "Slide Left" },
    { value: "slideRight", label: "Slide Right" }
  ],

  transform: [
    { value: "spin", label: "Spin" }
  ],

  blur: [
    { value: "zoomBlur", label: "Zoom Blur" }
  ]
};


const outCatSel = document.getElementById("outFxCategory");
const outFxSel  = document.getElementById("outFx");

function populateOutFx(category, preserveValue = true) {
  const prev = outFxSel.value;
  outFxSel.innerHTML = "";

  for (const fx of OUT_EFFECTS[category] || []) {
    const opt = document.createElement("option");
    opt.value = fx.value;
    opt.textContent = fx.label;
    outFxSel.appendChild(opt);
  }

  if (preserveValue && [...outFxSel.options].some(o => o.value === prev)) {
    outFxSel.value = prev;
  }
}

outCatSel.addEventListener("change", () => {
  populateOutFx(outCatSel.value, false);
});

function setOutFxFromConfig(value) {
  for (const [cat, list] of Object.entries(OUT_EFFECTS)) {
    if (list.some(fx => fx.value === value)) {
      outCatSel.value = cat;
      populateOutFx(cat, false);
      outFxSel.value = value;
      return;
    }
  }
}




const catSel = document.getElementById("inFxCategory");
const fxSel  = document.getElementById("inFx");

function populateInFx(category, preserveValue = true) {
  const prev = fxSel.value;
  fxSel.innerHTML = "";

  for (const fx of IN_EFFECTS[category] || []) {
    const opt = document.createElement("option");
    opt.value = fx.value;
    opt.textContent = fx.label;
    fxSel.appendChild(opt);
  }

  if (preserveValue && [...fxSel.options].some(o => o.value === prev)) {
    fxSel.value = prev;
  }
}

catSel.addEventListener("change", () => {
  populateInFx(catSel.value, false);
});

function setInFxFromConfig(value) {
  for (const [cat, list] of Object.entries(IN_EFFECTS)) {
    if (list.some(fx => fx.value === value)) {
      catSel.value = cat;
      populateInFx(cat, false);
      fxSel.value = value;
      return;
    }
  }
}



const VAYL_BASE = "http://127.0.0.1:5000";

const QS = new URLSearchParams(location.search);
const isLive = QS.has("data");
const isDebug = QS.get("debug") === "1" || QS.get("debug") === "true";

const overlay = document.getElementById("overlay");
const editor = document.getElementById("editor");
const hud = document.getElementById("hud");

function showHUD(msg) {
  hud.style.display = "none";
  hud.textContent = msg;
  return;
}

/* ---------- Config encode/decode (simple base64url JSON) ----------
   NOTE: This is not compressed to keep this file dependency-free.
   If you want compression, swap these with pako deflate/inflate.
------------------------------------------------------------------ */
function b64urlEncode(str) {
  const b64 = btoa(unescape(encodeURIComponent(str)));
  return b64.replaceAll("+","-").replaceAll("/","_").replaceAll("=","");
}
function b64urlDecode(b64url) {
  let b64 = b64url.replaceAll("-","+").replaceAll("_","/");
  const pad = b64.length % 4;
  if (pad) b64 += "=".repeat(4 - pad);
  return decodeURIComponent(escape(atob(b64)));
}
function encodeConfig(obj) {
  return b64urlEncode(JSON.stringify(obj));
}
function decodeConfig(data) {
  return JSON.parse(b64urlDecode(data));
}

/* ---------- Templates (keep small; can expand later) ---------- */
const TEMPLATES = {
  neo_fade: {
    name: "neo_fade",
    bgFallback: "",
    stageScale: 1,
    // If bgUrl not provided, use a subtle gradient.
    applyBg(bgEl, cfg) {
      if (cfg.bgUrl) {
        bgEl.style.backgroundImage = `url("${cfg.bgUrl}")`;
        bgEl.style.backgroundColor = "transparent";
      } else {
        bgEl.style.backgroundImage = "";
        bgEl.style.backgroundColor = "rgba(255,255,255,0.04)";
        bgEl.style.border = "1px solid rgba(255,255,255,0.12)";
      }
    }
  },
  minimal_pop: {
    name: "minimal_pop",
    bgFallback: "",
    stageScale: 1,
    applyBg(bgEl, cfg) {
      if (cfg.bgUrl) {
        bgEl.style.backgroundImage = `url("${cfg.bgUrl}")`;
        bgEl.style.backgroundColor = "transparent";
      } else {
        bgEl.style.backgroundImage = "";
        bgEl.style.backgroundColor = "rgba(0,0,0,0.55)";
        bgEl.style.border = "1px solid rgba(255,255,255,0.14)";
      }
    }
  }
};

/* ---------- Rendering ---------- */
const stage = document.getElementById("stage");
const bg = document.getElementById("bg");
const alertText = document.getElementById("alertText");

function cssFontFamily(font) {
  if (!font || font === "system") return "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
  return `"${font}", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
}

function renderTextWithTokens(template, payload, cfg) {
  // Basic token replacement with styling for {user}.
  // Extend later for more tokens like {tier}, {amount}, etc.
  const user = (payload && payload.user) ? String(payload.user) : "Someone";

  // We build HTML with minimal escaping (escape template & payload).
  const escapeHtml = (s) => s
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");

  const safeTemplate = escapeHtml(String(template ?? "NEW FOLLOWER\n{user}"));
  const safeUser = escapeHtml(user);

  // Replace {user} occurrences with span
  const html = safeTemplate.replaceAll("{user}", `<span class="token user">${safeUser}</span>`);
  return html;
}

function applyCfgToDOM(cfg, payload) {
  const tpl = TEMPLATES[cfg.template] || TEMPLATES.neo_fade;

  tpl.applyBg(bg, cfg);

  stage.style.transform = `scale(${tpl.stageScale || 1})`;

  alertText.style.fontFamily = cssFontFamily(cfg.font);
  alertText.style.fontSize = `${Number(cfg.fontSize || 30)}px`;
  alertText.style.color = cfg.color || "#FFFFFF";

  // Token color
  const userColor = (cfg.tokenColors && cfg.tokenColors.user) ? cfg.tokenColors.user : (cfg.userColor || "#EF767A");
  // Apply via inline style tagless: set CSS variable or just set style on spans after render.
  alertText.innerHTML = renderTextWithTokens(cfg.text, payload, cfg);
  const userSpans = alertText.querySelectorAll(".token.user");
  userSpans.forEach(sp => sp.style.color = userColor);


  removeClassesByPrefix(alertText, ["fx-"]);
  alertText.classList.add("fx-" + (cfg.textFx || "none"));

  removeClassesByPrefix(stage, ["anim-in-", "anim-out-"]);

  // Animation durations
  stage.style.setProperty("--in-ms", `${Number(cfg.inMs || 450)}ms`);
  stage.style.setProperty("--out-ms", `${Number(cfg.outMs || 450)}ms`);
}

/* ---------- Audio ---------- */
async function playSound(cfg) {
  const s = (cfg.sound || "").trim();
  if (!s) return;

  // If it looks like a URL, use it, otherwise assume relative to current path /sounds/
  const isUrl = /^https?:\/\//i.test(s);
  const url = isUrl ? s : `${location.origin}/alert/sounds/${encodeURIComponent(s)}`;

  try {
    const audio = new Audio(url);
    audio.volume = 1.0;
    // Some environments require user interaction; OBS usually allows autoplay.
    await audio.play();
  } catch (e) {
    // showHUD((hud.textContent || "") + `\n[sound] failed: ${String(e)}`);
  }
}

/* ---------- Live playback ---------- */
function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

function removeClassesByPrefix(el, prefixes) {
  [...el.classList].forEach(cls => {
    if (prefixes.some(p => cls.startsWith(p))) {
      el.classList.remove(cls);
    }
  });
}


async function playOnce(cfg, payload) {
  applyCfgToDOM(cfg, payload);
  stage.style.opacity = "1";


  // Force reflow to restart animations
  void stage.offsetHeight;

  // In
  const inClass = "anim-in-" + (cfg.inFx || "fadeUp");
  stage.classList.add(inClass);

  // Sound near start
  if (cfg.playSound !== false) playSound(cfg);

  // Hold
  const total = Number(cfg.durationMs || 5500);
  const inMs = Number(cfg.inMs || 450);
  const outMs = Number(cfg.outMs || 450);
  const holdMs = Math.max(0, total - inMs - outMs);

  await sleep(inMs + holdMs);

  // Out
  stage.classList.remove(inClass);
  const outClass = "anim-out-" + (cfg.outFx || "fadeDown");
  stage.classList.add(outClass);

  await sleep(outMs);

  stage.classList.remove(outClass);
  stage.style.opacity = "0";


}

/* ---------- Polling (queue consumer) ---------- */
let locked = false;
let lastPollAt = 0;

async function fetchJson(url, opts) {
  const res = await fetch(url, opts);
  if (res.status === 204) return { _noContent: true };
  const ct = res.headers.get("content-type") || "";
  if (!ct.includes("application/json")) {
    const txt = await res.text();
    throw new Error(`Expected JSON, got: ${ct} :: ${txt.slice(0,120)}`);
  }
  return await res.json();
}

async function pollLoop(cfg) {
  const base = VAYL_BASE;
  const type = cfg.type || "follow";
  const source = cfg.source || "followWidget";

  const pollEveryMs = Number(cfg.pollMs || 300); // "few times a second"
  const idleBackoffMs = Number(cfg.idleBackoffMs || 700); // when empty

  while (true) {
    if (locked) {
      await sleep(200);
      continue;
    }

    lastPollAt = Date.now();
    // showHUD(`mode=LIVE debug=1\npolling=${base}\nlastPoll=${new Date(lastPollAt).toLocaleTimeString()}\nlocked=${locked}`);

    let next;
    try {
      next = await fetchJson(`${base}/alerts/next?type=${encodeURIComponent(type)}&source=${encodeURIComponent(source)}`, {
        method: "GET",
        headers: { "Accept": "application/json" }
      });
    } catch (e) {
      // showHUD(`mode=LIVE debug=1\nERROR polling\n${String(e)}\nRetrying...`);
      await sleep(1000);
      continue;
    }

    if (next && next._noContent) {
      await sleep(idleBackoffMs);
      continue;
    }

    if (!next || !next.id || !next.payload) {
      // Defensive: treat as empty
      await sleep(idleBackoffMs);
      continue;
    }

    // Lock and play
    locked = true;
    // showHUD(`mode=LIVE debug=1\nCLAIMED id=${next.id}\nuser=${next.payload.user ?? ""}`);

    try {
      await playOnce(cfg, next.payload);
    } catch (e) {
      // showHUD(`mode=LIVE debug=1\nPLAY ERROR id=${next.id}\n${String(e)}`);
    }

    // Consume
    try {
      await fetchJson(`${base}/alerts/consume`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "Accept": "application/json" },
        body: JSON.stringify({ id: next.id, source })
      });
    } catch (e) {
      // If consume fails, you may replay on next startup depending on server logic.
      // showHUD(`mode=LIVE debug=1\nCONSUME ERROR id=${next.id}\n${String(e)}`);
    }

    locked = false;
    await sleep(pollEveryMs);
  }
}

/* ---------- Mode bootstrap ---------- */
function bootEditor() {
  editor.style.display = "block";

  populateInFx(catSel.value, false);
  populateOutFx(outCatSel.value, false);


  const els = {
    tpl: document.getElementById("tpl"),
    bgUrl: document.getElementById("bgUrl"),
    txt: document.getElementById("txt"),
    font: document.getElementById("font"),
    fontSize: document.getElementById("fontSize"),
    color: document.getElementById("color"),
    userColor: document.getElementById("userColor"),
    inFx: document.getElementById("inFx"),
    outFx: document.getElementById("outFx"),
    textFx: document.getElementById("textFx"),
    dur: document.getElementById("dur"),
    inMs: document.getElementById("inMs"),
    outMs: document.getElementById("outMs"),
    sound: document.getElementById("sound"),
    copyUrl: document.getElementById("copyUrl"),
    openLive: document.getElementById("openLive"),
    previewFrame: document.getElementById("previewFrame"),
    testAnim: document.getElementById("testAnim"),
  };


	
	els.loadUrl = document.getElementById("loadUrl");
	els.loadBtn = document.getElementById("loadBtn");

	els.loadBtn.onclick = () => {
	  try {
		const raw = els.loadUrl.value.trim();
		if (!raw) return;

		const url = new URL(raw);
		const data = url.searchParams.get("data");

		if (!data) {
		  alert("That URL does not contain a ?data= parameter.");
		  return;
		}

		const cfg = decodeConfig(data);

		// Hydrate editor inputs (best-effort)
		if (cfg.template) els.tpl.value = cfg.template;
		if (cfg.bgUrl !== undefined) els.bgUrl.value = cfg.bgUrl;
		if (cfg.text !== undefined) els.txt.value = cfg.text;
		if (cfg.font) els.font.value = cfg.font;
		if (cfg.fontSize) els.fontSize.value = cfg.fontSize;
		if (cfg.color) els.color.value = cfg.color;
		if (cfg.tokenColors?.user) els.userColor.value = cfg.tokenColors.user;
		
		if (cfg.inFx) setInFxFromConfig(cfg.inFx);
		if (cfg.outFx) setOutFxFromConfig(cfg.outFx);

		if (cfg.textFx) els.textFx.value = cfg.textFx;
		if (cfg.durationMs) els.dur.value = cfg.durationMs;
		if (cfg.inMs) els.inMs.value = cfg.inMs;
		if (cfg.outMs) els.outMs.value = cfg.outMs;
		if (cfg.sound) els.sound.value = cfg.sound;

		refreshPreview();

	  } catch (err) {
		console.error(err);
		alert("Invalid URL or alert config.");
	  }
	};








  function buildCfg() {
    return {
      v: 1,
      type: "follow",
      template: els.tpl.value,
      bgUrl: els.bgUrl.value.trim(),
      text: els.txt.value,
      font: els.font.value,
      fontSize: Number(els.fontSize.value || 30),
      color: els.color.value.trim() || "#FFFFFF",
      tokenColors: { user: (els.userColor.value.trim() || "#81A4CD") },
      inFx: els.inFx.value,
      outFx: els.outFx.value,
      textFx: els.textFx.value,
      durationMs: Number(els.dur.value || 5500),
      inMs: Number(els.inMs.value || 450),
      outMs: Number(els.outMs.value || 450),
      sound: els.sound.value.trim(),
      pollMs: 300,
      idleBackoffMs: 700,
      source: "followWidget",
      // editor-only: allow fake event via ?demo=1
    };
  }

  function liveUrl(cfg, extraParams = {}) {
    const data = encodeConfig(cfg);
    const u = new URL(location.href);
    u.search = ""; // reset
    u.searchParams.set("data", data);
    for (const [k,v] of Object.entries(extraParams)) u.searchParams.set(k, String(v));
    return u.toString();
  }

  function refreshPreview() {
    const cfg = buildCfg();
    const url = liveUrl(cfg, { demo: "1" });
    els.previewFrame.src = url;
  }

  // Bind changes
  [
    els.tpl, els.bgUrl, els.txt, els.font, els.fontSize, els.color, els.userColor,
    els.inFx, els.outFx, els.textFx, els.dur, els.inMs, els.outMs, els.sound
  ].forEach(el => el.addEventListener("input", refreshPreview));


  els.copyUrl.addEventListener("click", async () => {
    const cfg = buildCfg();
    const url = liveUrl(cfg);
    await navigator.clipboard.writeText(url);
    els.copyUrl.textContent = "Copied!";
    setTimeout(() => els.copyUrl.textContent = "Copy LIVE URL", 900);
  });

  els.openLive.addEventListener("click", () => {
    const cfg = buildCfg();
    window.open(liveUrl(cfg, { debug: "1" }), "_blank");
  });

  els.testAnim.addEventListener("click", () => {
    const cfg = buildCfg();
    const url = liveUrl(cfg, { demo: "1", debug: "1" });
    els.previewFrame.src = url;
  });

  refreshPreview();
}

async function bootLive() {
  overlay.style.display = "flex";
  if (isDebug) hud.style.display = "block";

  let cfg;
  try {
    cfg = decodeConfig(QS.get("data"));
  } catch (e) {
    // showHUD(`Invalid data param.\n${String(e)}`);
    return;
  }



  // Demo mode: plays a fake event once, then idles (no polling)
  const demo = QS.get("demo") === "1";
  if (demo) {
    // showHUD(`mode=LIVE demo=1 debug=${isDebug ? 1 : 0}\n(no polling)`);
    const payload = { user: "CaptainCapy" };
    await playOnce(cfg, payload);
    return;
  }

  // showHUD(`mode=LIVE debug=${isDebug ? 1 : 0}\nwaiting...`);
  pollLoop(cfg);
}

/* ---------- Kick off ---------- */
if (isLive) bootLive();
else bootEditor();
</script>

</body>
</html>
